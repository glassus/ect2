# TD08 : SQL, matrices, simulations



{{initexo(0)}}

## 1. Entraînement SQL

!!! abstract "{{ exercice() }}"

    [Lien vers le cours de SQL](https://glassus.github.io/ect2/CoursSQL/langage_SQL/){. target="_blank"}

  
    On étudie (encore) une base de données sur le cinéma, qui possède deux tables, ```movies``` et ```actors```.

    ![image](data/cap_cinema.png){: .center width=80%}
    
    - la table ```movies``` possède un attribut ```id``` qui est sa clé primaire.
    - la table ```actors``` possède un attribut ```id``` qui est sa clé primaire. Elle possède aussi un attribut ```movie_id```, qui fait référence à l'attribut ```id``` de la table ```movies```. ```movie_id``` est donc une clé étrangère.     


    !!! note "Question 1"
        Afficher le titre et le nom du réalisateur de tous les films **français**.

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/cinema.db", espace="cinema" }!}

        
        ??? tip "Correction"
            ```SQL
            SELECT title, director FROM movies
            WHERE country = "France"
        
            ```
        
        


    !!! note "Question 2"
        
        Le titre du film «Intouchables» de Nakache et Toledano apparaît comme «The Intouchables». Modifier ce titre pour qu'il apparaisse sous le nom «Intouchables».

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/cinema.db", espace="cinema" }!}


        Vérifier si votre modification est correcte :

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/cinema.db", espace="cinema" }!}


        
        ??? tip "Correction"
            ```SQL
            UPDATE movies
            SET title = "Intouchables"
            WHERE title = "The Intouchables"
            ```
        
        

    !!! note "Question 3"
        Le réalisateur Carl Theodor Dreyer est un réalisateur Danois qui est manifestement là par erreur. Supprimer totalement de la table ```movies``` tous les films de ce réalisateur.

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/cinema.db", espace="cinema" }!}

        
        ??? tip "Correction"
            ```SQL
            DELETE FROM movies
            WHERE director = "Carl Theodor Dreyer"
            ```
        Vérifier si votre modification est correcte :

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/cinema.db", espace="cinema" }!}
      

    !!! note "Question 4"
        Afficher le titre de tous les films dans lesquels a joué l'acteur Mathieu Kassovitz.

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/cinema.db", espace="cinema" }!}

        
        ??? tip "Correction"
            ```SQL
            SELECT title FROM movies
            INNER JOIN actors ON movies.id = actors.movie_id
            WHERE name = 'Mathieu Kassovitz'"      
            ```

## 2. Retour sur les matrices

!!! note ":heart: :heart: :heart: Syntaxe des opérations matricielles :heart: :heart: :heart:"
    :arrow_right: **Saisir une matrice**  
    La matrice 
    $A=\begin{pmatrix}
    1 & 2 & 3 \\
    4 & 5 & 6 \\
    7 & 8 & 9
    \end{pmatrix}$
    se saisira par le code suivant :
    ```python 
    import numpy as np
    A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    ```
    :arrow_right: **Saisir un vecteur**  
    Le vecteur 
    $X=\begin{pmatrix}
    1 \\
    2 \\
    3 
    \end{pmatrix}$
    se saisira par le code suivant :
    ```python
    X = np.array([1, 2, 3])
    ```

    :arrow_right: **Effectuer un produit matriciel**  
    Le calcul du produit matriciel $A \times X$ se fera par le code suivant : 
    ```python
    >>> np.dot(A, X)
    array([14, 32, 50])
    ```




!!! abstract "{{ exercice() }}"
    *d'après le sujet 0 n°2 Ecricome 2023*

    On note
    $B=\begin{pmatrix}
    -1 & 4 & -1 \\
    -2 & 5 & 2 \\
    0 & 0 & -2
    \end{pmatrix}$,
    $P=\begin{pmatrix}
    1 & 2 & 1 \\
    0 & 1 & 1 \\
    1 & 0 & 0
    \end{pmatrix}$,
    $Q=\begin{pmatrix}
    0 & 0 & 1 \\
    1 & -1 & -1 \\
    -1 & 2 & 1
    \end{pmatrix}$ et
    $D=\begin{pmatrix}
    -2 & 0 & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 3
    \end{pmatrix}$,

    **Q1.** Créer en Python la variable ```B``` correspondant à la matrice $B$, ainsi que les variables ```X1```, ```X2```, ```X3``` correspondant respectivement aux vecteurs $X_1$, $X_2$ et $X_3$ ci-dessous :

    $X_1=\begin{pmatrix}
    1  \\
    0  \\
    1 
    \end{pmatrix}$,
    $X_2=\begin{pmatrix}
    2  \\
    1  \\
    0 
    \end{pmatrix}$,
    $X_3=\begin{pmatrix}
    1  \\
    1  \\
    0 
    \end{pmatrix}$
    
    ??? tip "Correction"
        ```python linenums='1'
        import numpy as np

        B = np.array([[-1, 4, -1], [-2, 5, 2], [0, 0, -2]])
        X1 = np.array([1, 0, 1])
        X2 = np.array([2, 1, 0])
        X3 = np.array([1, 1, 0])
        ```
    
    **Q2.** Par des calculs en Python, montrer que les vecteurs $X_1$, $X_2$ et $X_3$ sont des vecteurs propres de la matrice $B$, et préciser pour chacun la valeur propre associée.

    ??? tip "Correction"
        ```python
        >>> np.dot(B, X1)
        array([-2,  0, -2])
        >>> np.dot(B, X2)
        array([2, 1, 0])
        >>> np.dot(B, X3)
        array([3, 3, 0])
        ```
        On en déduit que :
        
        - $BX_1 = 2X_1$, donc $X_1$ est un vecteur propre associé à la valeur propre 2.
        - $BX_2 = X_2$, donc $X_2$ est un vecteur propre associé à la valeur propre 1.
        - $BX_3 = 3X_3$, donc $X_3$ est un vecteur propre associé à la valeur propre 3.

    
    **Q3.** On considère le script Python suivant :
    ```python linenums='1'
    import numpy as np

    I = np.eye(3)
    B = np.array([[-1, 4, -1], [-2, 5, 2], [0, 0, -2]])
    P = np.array([[1, 2, 1], [0, 1, 1], [1, 0, 0]])
    Q = np.array([[0, 0, 1], [1, -1, -1], [-1, 2, 1]])
    R = np.dot(P, Q) - I
    S = np.dot(Q, np.dot(B, P))

    print(R)
    print(S)
    ```
    À son exécution, on obtient :
    ```python
    [[0. 0. 0.]
     [0. 0. 0.]
     [0. 0. 0.]]
    [[-2  0  0]
     [ 0  1  0]
     [ 0  0  3]]
    ```

    Que peut-on en conjecturer sur la matrice $P$ ? sur la matrice $D$ ?

    ??? tip "correction"
        - On remarque que la matrice $R$ est une matrice nulle. Comme $R=PQ-I$, cela signifie que $PQ=I$ et donc que $P$ et $Q$ sont deux matrices inverses.  

        - On remarque que la matrice $S$ est égale à la matrice $D$. Donc $D=QBP=P^{-1}BP$.  
        Or la matrice $P$ est formée des trois vecteurs propres $X_1$, $X_2$ et $X_3$ de la matrice $B$, c'est donc sa matrice de passage. Le calcul $P^{-1}BP$ va donc donner la matrice diagonale associée à $B$.  
        On reconnaît d'ailleurs que $D$ est bien formée des 3 valeurs propres trouvées à la question précédente.


## 3. Retour sur les simulations


!!! note ":heart: :heart: :heart: Syntaxe des lois usuelles :heart: :heart: :heart:"
    Rappel : on utilise les simulateurs de lois du module ```random``` de la bibliothèque ```numpy```.  
    Ceci nécessite systématiquement la présence des deux lignes suivantes au début de chaque script :
    ```python linenums='1'
    import numpy as np
    import numpy.random as rd   
    ```  

    - :arrow_right: **loi uniforme** : 
        - ```rd.random()``` renvoie un réel dans $[0;1]$ qui suit une loi uniforme (chaque réel a la même probabilité d'apparition)
        - ```rd.randint(a,b)``` renvoie un entier dans $[a;b[$ qui suit une loi uniforme (chaque entier a la même probabilité d'apparition). Attention, la valeur $b$ n'est pas prise. Ce qui signifie que pour un tirage aléatoire uniforme de 0 et de 1, il faut utiliser l'expression ```rd.randint(0,2)```.

    - :arrow_right: **loi binomiale** : ```rd.binomial(n,p)``` renvoie un entier qui suit une loi binomiale de paramètre $(n,p)$. ($n$ répétitions d'une épreuve de Bernoulli de paramètre $p$)

    - :arrow_right: **loi géométrique** : ```rd.geometric(p)``` renvoie un entier qui suit une loi géométrique de paramètre $p$ (nombre d'expériences de Bernoulli de paramètre $p$ avant l'apparition du premier succès)

    - :arrow_right: **loi exponentielle** : ```rd.exponential(1/lambda)``` renvoie un réel qui suit une loi exponentielle de paramètre ```lambda```.


    :star: Comment renvoyer un **vecteur** plutôt qu'une seule valeur unique ? Il suffit de rajouter le nombre de simulations désirées comme dernier paramètre dans la parenthèse.

    **Exemple :**  
    Pour simuler 10 tirages aléatoires de nombres égaux à 0 ou à 1, on utilisera :
    ```python
    >>> X = rd.randint(0,2,10)
    >>> X
    array([0, 1, 0, 0, 1, 0, 0, 0, 1, 1])
    ```

    Pour connaître la valeur du 5ème tirage, on appelera :
    ```python
    >>> X[4]
    1
    ```
    :warning: Ne pas oublier qu'on commence à indexer à 0, donc le 5ème élément est l'élément d'indice 4...


:arrow_right: [Lien pour ouvrir une console Python dans un nouvel onglet](https://console.basthon.fr/){. target="_blank"} (sous Chrome de préférence)

   



!!! abstract "{{ exercice() }}"
    *d'après BCE ESC 2020*

    Un mobile se déplace sur les points à coordonnées entières positives d'un axe d'origine $O$.  
    Au départ, le mobile est à l'origine (point d'abscisse 0). Le mobile se déplace selon la règle suivante : s'il est sur le point d'abscisse $k-1$ ($k \in \mathbb{N}^*$) à l'instant $n$ ($n \in \mathbb{N}$), alors, à l'instant $n+1$, il sera sur le point d'abscisse $k$ avec la probabilité $\frac{k}{k+1}$, ou sur le point d'abscisse 0 avec la probabilité $\frac{1}{k+1}$.


    On note $U$ l'instant auquel le mobile se trouve pour la première fois à l'origine (sans compter son positionnement de départ) et on admet que $U$ est une variable aléatoire. 

    Compléter les commandes du script Python suivant afin qu'il calcule et affiche la valeur prise par $U$ lors de l'expérience aléatoire étudiée.

    ```python linenums='1'
    import numpy as np
    import numpy.random as rd

    k = 1
    hasard = rd.randint(1, k+2)
    while hasard < ...:
        k = k + 1
        hasard = ...

    print('U a pris la valeur', ...)
    ```

    {#
    ??? tip "Correction"
        ```python linenums='1' hl_lines='6 8 10'
        import numpy as np
        import numpy.random as rd

        k = 1
        hasard = rd.randint(1, k+2)
        while hasard < k+1:
            k = k + 1
            hasard = rd.randint(1, k+2)

        print('U a pris la valeur', k)
        ```
    #}
