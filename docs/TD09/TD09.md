# TD09 : retour du SQL, régression, simulations



{{initexo(0)}}

## 1. Entraînement SQL

!!! abstract "{{ exercice() }}"

    [Lien vers le cours de SQL](https://glassus.github.io/ect2/CoursSQL/langage_SQL/){. target="_blank"}

  
    On étudie une base de données ```parc```, relative à un parc automobile.  
    Cette base possède deux tables, ```personnes``` et ```voitures```.

     
    - la table ```personnes``` possède comme attributs :
        - ```id``` : un numéro d'identification unique pour chaque personne.
        - ```nom```, ```prenoms```, ```code postal```, ```ville``` 

    - la table ```voitures``` possède  comme attributs :
        - ```immatriculation``` : le numéro d'immatriculation unique pour chaque voiture
        - ```modele```, ```marque```, ```couleur```
        - ```proprietaire``` : cet attribut fait référence à l'attribut ```id``` de la table ```personnes```.      

    !!! note "Questions 0"
        1. Quel rôle joue l'attribut ```immatriculation``` dans la table ```voitures``` ?  
        2. Quel rôle joue l'attribut ```proprietaire``` dans la table ```voitures``` ? 
        
        ??? tip "Correction"
            1. ```immatriculation``` est la clé **primaire** la table ```voitures```. 
            2. ```proprietaire``` une clé **étrangère** de la table ```voitures```, elle fait référence à la clé primaire ```id``` de la table ```personnes```. 



    !!! note "Question 1"
        Afficher tout le contenu de la table ```personnes```.

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/parc.db", espace="parc"}!}

        
        ??? tip "Correction"
            ```SQL
            SELECT *
            FROM personnes     
            ```
        
    !!! note "Question 2"
        Afficher tout le contenu de la table ```voitures```.

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/parc.db", espace="parc"}!}

        
        ??? tip "Correction"
            ```SQL
            SELECT *
            FROM voitures     
            ```  

    !!! note "Question 3"
        Donner la plaque d'immatriculation de la voiture rose.

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/parc.db", espace="parc"}!}

        
        ??? tip "Correction"
            ```SQL
            SELECT immatriculation 
            FROM voitures
            WHERE couleur = 'Rose'     
            ```  

    !!! note "Question 4"
        Insérer dans la table ```personnes``` l'individu Gerard Berry, habitant à Bordeaux (33000) ayant pour ```id``` la valeur 5. 

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/parc.db", espace="parc"}!}

        Pour vérifier si la table a bien été modifiée :

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/parc.db", espace="parc"}!}

        
        ??? tip "Correction"
            ```SQL
            INSERT INTO personnes
            VALUES (5, "Berry", "Gérard", 33000, "Bordeaux")     
            ```  

    !!! note "Question 5"
        Donner le nom et le prénom du propriétaire de la Porsche.

        {!{ sqlide titre="Votre code SQL :"  base="CoursSQL/data/parc.db", espace="parc"}!}

        
        ??? tip "Correction"
            ```SQL
            SELECT nom, prenom 
            FROM personnes
            INNER JOIN voitures ON voitures.proprietaire = personnes.id
            WHERE marque = "Porsche"     
            ```  





## 2. Retour sur la régression linéaire

!!! note "Coefficient de corrélation linéaire de deux variables aléatoires"
    :arrow_right: **Définition**  
    Le coefficient de corrélation linéaire de deux variables aléatoires $X$ et $Y$ est le réel $\rho(X,Y)$ donné par la formule :
                
    $$\rho(X,Y) = \dfrac{Cov(X,Y)}{\sqrt{V(X)}\sqrt{V(Y)}}$$

    :arrow_right: **Interprétation**   

    - Si $X$ et $Y$ sont indépendantes, alors $\rho(X,Y) = 0$
    - Si $X$ et $Y$ sont liées par une combinaison linéaire (ex : $Y = 3X+2$), alors $\rho(X,Y) = \pm 1$

    :arrow_right: **Utilisation en statistiques**   
    Lorsque $\rho$ est *proche* de 1, on peut conjecturer que le phénomène observé est prédictible. Le tracé de la droite de régression permet alors de faire des prévisions.



!!! note "Syntaxe Python :heart: :heart: :heart:"
    
    :arrow_right: **Calcul du coefficient de corrélation :** ```np.corrcoef(x,y)[0,1]```

    Considérons le code suivant :

    ```python linenums='1'
    import numpy as np
    import matplotlib.pyplot as plt
    plt.clf()

    x = np.array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
           17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
           34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49])

    y = np.array([ 0,  1,  7,  1,  4, 17,  7,  4, 18, 10, 11, 11, 16, 15, 19, 19, 20,
           25, 33, 23, 26, 44, 27, 34, 35, 34, 32, 46, 32, 38, 44, 47, 43, 49,
           41, 52, 40, 59, 55, 58, 69, 66, 67, 71, 71, 68, 76, 75, 71, 68])

    coeff = np.corrcoef(x,y)[0,1]

    plt.scatter(x,y)
    print(coeff)

    plt.show()
    ```

    Le tracé laisse apparaître une distribution des points qui semblent être situés autour d'une droite. Ceci est confirmé par le calcul du coefficient de corrélation linéaire (:heart: **calculé par l'instruction** ```np.corrcoef(x,y)[0,1]``` :heart: )

    ![image](data/Figure_1.png){: .center}

    :arrow_right: **Calcul et tracé du point moyen :** ```np.mean(x)```

    La fonction ```np.mean(x)``` permet de calculer la valeur moyenne d'un ensemble de valeurs stockées dans la variable ```x```.

    Le point moyen d'une série statistique double peut donc se tracer par :
    ```python
    plt.plot([np.mean(x)], [np.mean(y)], 'r+') 
    ```

    ![image](data/Figure_8.png){: .center}



    :arrow_right: **Tracé de la droite de régression :** ```a, b = np.polyfit(x, y, 1)```

    - Le calcul du coefficient directeur ```a``` et de l'ordonnée à l'origine ```b``` de la droite de régression se fait par la commande  :heart: ```a, b = np.polyfit(x, y, 1)``` :heart:
    - Le tracé de la droite se fait par `plt.plot(x, a*x + b)`


    Insérer les lignes :
    ```python
    a, b = np.polyfit(x, y, 1)
    plt.plot(x, a*x + b, 'g-')
    ```
    dans le code précédent. On obtient alors :
    ![image](data/Figure_9.png){: .center}






!!! abstract "{{ exercice() }}"

    Pour chaque question :
    
    - Représenter le nuage de points de la série statistique.
    - Calculer le coefficient de corrélation linéaire.
    - Dire si un ajustement linéaire est possible. 
    - Si oui, représenter la droite de régression et faire une estimation de la valeur de ```y``` pour ```x = 30```.

    **Q1.**

    ```python
    x = np.array([0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
    y = np.array([0, 17, 11, 15, 15, 2, 7, 18, 0, 6, 9, 10, 9, 5, 16, 17, 7, 0, 18, 4])
    ```

    ??? tip "correction **Q1.**"
        ```python linenums='1'
        import numpy as np
        import matplotlib.pyplot as plt

        plt.clf()

        x = np.array([0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
        y = np.array([0, 17, 11, 15, 15, 2, 7, 18, 0, 6, 9, 10, 9, 5, 16, 17, 7, 0, 18, 4])

        coeff = np.corrcoef(x,y)[0,1]
        print(coeff)

        plt.scatter(x,y)
        plt.show()
        ```
        ![image](data/Q1.png){: .center}
        ```r = -0.037``` donc on ne peut absolument pas tenter un ajustement linéaire. 
        

    **Q2.**

    ```python
    x = np.array([0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
    y = np.array([108, 75, 58, 57, 42, 38, 29, 16, -9, 5, 5, 1, -10, 13, 7, 39, 38, 42, 72, 70])
    ```

    ??? tip "correction **Q2.**"
        ![image](data/Q2.png){: .center}
        ```r = -0.249``` donc on ne peut absolument pas tenter un ajustement linéaire. 
        

    **Q3.**

    ```python
    x = np.array([0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
    y = np.array([346, 343, 322, 321, 302, 301, 287, 269, 272, 257, 257, 249, 226, 227, 208, 201, 175, 191, 169, 158])
    ```

    ??? tip "correction **Q3.**"
        ![image](data/Q3.png){: .center}
        ```r = -0.993``` donc il est légitime tenter un ajustement linéaire. 

        Insérons (avant le tracé par ```plt.show()```) le code suivant :
        ```python
        a, b = np.polyfit(x, y, 1)
        plt.plot(x,a*x+b, 'r-')
        ```
        
        ![image](data/Q3bis.png){: .center}
        ```python
        >>> a
        -9.808270676691734
        >>> b
        347.2285714285715
        >>> a*30+b
        52.98045112781949
        ```
        On peut donc estimer que quand ```x``` vaudra 30, ```y``` vaudra environ 53.
    


!!! note ":star: :star: :star: HorsProgramme :star: :star: :star: retour sur la question **Q2**"    
    
    Le nuage de points obtenu en **Q2** ne donne absolument pas envie de faire un ajustement linéaire : la forme du nuage ne ressemble pas du tout à une droite.

    Par contre, elle ressemble à une parabole... 

    Peut-on ajuster cette série statistique avec un polynôme de degré 2 ? Essayons !
    Il faut pour cela se servir de la fonction ```polyfit``` et lui demander les 3 coefficients du polynôme de degré 2 qui «fitte» le mieux notre nuage :

    ```python linenums='1'
    import numpy as np
    import matplotlib.pyplot as plt

    plt.clf()

    x = np.array([0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
    y = np.array([108, 75, 58, 57, 42, 38, 29, 16, -9, 5, 5, 1, -10, 13, 7, 39, 38, 42, 72, 70])

    plt.scatter(x,y)

    a, b, c = np.polyfit(x, y, 2)
    plt.plot(x, a*x**2 + b*x + c, 'r-')


    plt.show()
    ```

    ![image](data/fit.png){: .center}
    
    ```python
    >>> a*30**2 + b*30 + c
    383.80943267259056
    ```
    On peut alors estimer que quand ```x``` vaudra 30, ```y``` vaudra environ 383. 


    **Mais alors, en augmentant le degré, ne peut-on pas obtenir un ajustement parfait ???**

    :arrow_right: Réponse : si, on peut, mais c'est mal.

    **Exemple**

    Prenons ce nuage de points :
    ![image](data/over1.png){: .center}

    On peut le fitter assez proprement avec une parabole :

    ![image](data/over2.png){: .center}

    Mais ```polyfit``` est capable de mieux ! Il peut nous donner les coefficients du polynôme de degré 6 qui passera **parfaitement** par les 7 points :

    ```python
    a, b, c, d, e, f, g = np.polyfit(x, y, 6)
    ```     
    
    Traçons donc la courbe obtenue...

    ![image](data/over3.png){: .center}

    À trop vouloir coller aux valeurs données, on a perdu le «sens» de la série statistique, et nos prévisions risquent d'être totalement fausses. On appelle ce phénomène l'**overfitting**, ou **sur-apprentissage** en Intelligence Artificielle.  
    Une interprétation dans la vie courante pourrait être que lorsque vous savez **trop parfaitement** quelque chose, il y a un risque d'en perdre le sens et donc de ne pas pouvoir s'adapter en cas de léger décalage par rapport à ce que vous attendez.
    



## 3. Retour sur les simulations


!!! note ":heart: :heart: :heart: Syntaxe des lois usuelles :heart: :heart: :heart:"
    Rappel : on utilise les simulateurs de lois du module ```random``` de la bibliothèque ```numpy```.  
    Ceci nécessite systématiquement la présence des deux lignes suivantes au début de chaque script :
    ```python linenums='1'
    import numpy as np
    import numpy.random as rd   
    ```  

    - :arrow_right: **loi uniforme** : 
        - ```rd.random()``` renvoie un réel dans $[0;1]$ qui suit une loi uniforme (chaque réel a la même probabilité d'apparition)
        - ```rd.randint(a,b)``` renvoie un entier dans $[a;b[$ qui suit une loi uniforme (chaque entier a la même probabilité d'apparition). Attention, la valeur $b$ n'est pas prise. Ce qui signifie que pour un tirage aléatoire uniforme de 0 et de 1, il faut utiliser l'expression ```rd.randint(0,2)```.

    - :arrow_right: **loi binomiale** : ```rd.binomial(n,p)``` renvoie un entier qui suit une loi binomiale de paramètre $(n,p)$. ($n$ répétitions d'une épreuve de Bernoulli de paramètre $p$)

    - :arrow_right: **loi géométrique** : ```rd.geometric(p)``` renvoie un entier qui suit une loi géométrique de paramètre $p$ (nombre d'expériences de Bernoulli de paramètre $p$ avant l'apparition du premier succès)

    - :arrow_right: **loi exponentielle** : ```rd.exponential(1/lambda)``` renvoie un réel qui suit une loi exponentielle de paramètre ```lambda```.


    :star: Comment renvoyer un **vecteur** plutôt qu'une seule valeur unique ? Il suffit de rajouter le nombre de simulations désirées comme dernier paramètre dans la parenthèse.

    **Exemple :**  
    Pour simuler 10 tirages aléatoires de nombres égaux à 0 ou à 1, on utilisera :
    ```python
    >>> X = rd.randint(0,2,10)
    >>> X
    array([0, 1, 0, 0, 1, 0, 0, 0, 1, 1])
    ```

    Pour connaître la valeur du 5ème tirage, on appelera :
    ```python
    >>> X[4]
    1
    ```
    :warning: Ne pas oublier qu'on commence à indexer à 0, donc le 5ème élément est l'élément d'indice 4...


:arrow_right: [Lien pour ouvrir une console Python dans un nouvel onglet](https://console.basthon.fr/){. target="_blank"} (sous Chrome de préférence)

   



!!! abstract "{{ exercice() }}"
    *d'après BCE ESC 2020*

    Un mobile se déplace sur les points à coordonnées entières positives d'un axe d'origine $O$.  
    Au départ, le mobile est à l'origine (point d'abscisse 0). Le mobile se déplace selon la règle suivante : s'il est sur le point d'abscisse $k-1$ ($k \in \mathbb{N}^*$) à l'instant $n$ ($n \in \mathbb{N}$), alors, à l'instant $n+1$, il sera sur le point d'abscisse $k$ avec la probabilité $\frac{k}{k+1}$, ou sur le point d'abscisse 0 avec la probabilité $\frac{1}{k+1}$.


    On note $U$ l'instant auquel le mobile se trouve pour la première fois à l'origine (sans compter son positionnement de départ) et on admet que $U$ est une variable aléatoire. 

    Compléter les commandes du script Python suivant afin qu'il calcule et affiche la valeur prise par $U$ lors de l'expérience aléatoire étudiée.

    ```python linenums='1'
    import numpy as np
    import numpy.random as rd

    k = 1
    hasard = rd.randint(1, k+2)
    while hasard < ...:
        k = k + 1
        hasard = ...

    print('U a pris la valeur', ...)
    ```

    {#
    ??? tip "Correction"
        ```python linenums='1' hl_lines='6 8 10'
        import numpy as np
        import numpy.random as rd

        k = 1
        hasard = rd.randint(1, k+2)
        while hasard < k+1:
            k = k + 1
            hasard = rd.randint(1, k+2)

        print('U a pris la valeur', k)
        ```
    #}

