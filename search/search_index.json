{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"1. S\u00e9ances de Travaux Dirig\u00e9s \u2693\ufe0e S\u00e9ance en cours TD03 : retour sur les simulations S\u00e9ances pr\u00e9c\u00e9dentes TD02 : premi\u00e8res simulations TD01 : r\u00e9vision des structures \u00e9l\u00e9mentaires 2. Python en ligne sans installation \u2693\ufe0e Vous pouvez utiliser l'excellente solution Basthon :","title":"Accueil"},{"location":"#1-seances-de-travaux-diriges","text":"S\u00e9ance en cours TD03 : retour sur les simulations S\u00e9ances pr\u00e9c\u00e9dentes TD02 : premi\u00e8res simulations TD01 : r\u00e9vision des structures \u00e9l\u00e9mentaires","title":"1. S\u00e9ances de Travaux Dirig\u00e9s"},{"location":"#2-python-en-ligne-sans-installation","text":"Vous pouvez utiliser l'excellente solution Basthon :","title":"2. Python en ligne sans installation"},{"location":"Programme/1A/","text":"Programme ECT1 - partie informatique \u2693\ufe0e","title":"Programme de 1\u00e8re ann\u00e9e"},{"location":"Programme/1A/#programme-ect1-partie-informatique","text":"","title":"Programme ECT1 - partie informatique"},{"location":"Programme/2A/","text":"Programme ECT2 - partie informatique \u2693\ufe0e","title":"Programme de 2\u00e8me ann\u00e9e"},{"location":"Programme/2A/#programme-ect2-partie-informatique","text":"","title":"Programme ECT2 - partie informatique"},{"location":"Programme/commandes/","text":"Les commandes exigibles du programme officiel \u2693\ufe0e 1. Op\u00e9rateurs arithm\u00e9tiques de base \u2693\ufe0e Commande Signification Exemple Commentaires + addition >>> 5 + 2 7 - soustraction >>> 5 - 2 3 * multiplication >>> 5 * 2 10 / division >>> 7 / 2 3.5 >>> 10 / 2 5.0 Attention, le nombre renvoy\u00e9 par cette division est toujours un nombre \u00e0 virgule. ** puissance >>> 10 ** 3 1000 Attention, ce n'est pas le symbole ^ . 2. Op\u00e9rateurs logiques \u2693\ufe0e Python poss\u00e8de deux mots-cl\u00e9s r\u00e9serv\u00e9s True et False (appel\u00e9s bool\u00e9ens ). Commande Signification Exemple Commentaires and et >>> True and False False or ou >>> True or False True not n\u00e9gation >>> not(True) False 3. Op\u00e9rateurs de comparaison \u2693\ufe0e Ces op\u00e9rateurs de comparaison renvoient syst\u00e9matiquement soit True , soit False . Commande Signification Exemple Commentaires == test d'\u00e9galit\u00e9 >>> 4 + 3 == 8 - 1 True Attention \u00e0 ne pas confondre avec le symbole = qui ne sert qu'\u00e0 l'affectation > test de sup\u00e9riorit\u00e9 >>> 4 > 7 False >= test de sup\u00e9riorit\u00e9 large >>> 7 >= 7 True < test d'inf\u00e9riorit\u00e9 >>> 4 < 7 True <= test d'inf\u00e9riorit\u00e9 large >>> 4 <= 4 True != test de diff\u00e9rence >>> 3 + 2 != 4 True 4. Structures de contr\u00f4le \u2693\ufe0e Commande Signification Exemple Commentaires nom = expression affectation >>> a = 1 + 3 >>> a 4 La 1\u00e8re op\u00e9ration effectu\u00e9e est l'\u00e9valuation de la partie \u00e0 droite du = . if si if age >= 18: print(\"majeur\") Attention aux : en fin de ligne, attention \u00e0 l'indentation sous le if . else sinon if age >= 18: print(\"majeur\") else: print(\"mineur\") Attention \u00e0 l'indentation. elif sinon si if age >= 18: print(\"adulte\") elif age >= 14: print(\"ado\") else: print(\"enfant\") elif est une contraction d'un else et d'un if . Il permet de simplifier parfois les tests mais n'est jamais obligatoire. for ... in ... boucle for for n in [3, 5, 9]: print(\"gagn\u00e9 !\") La structure de boucle sert \u00e0 r\u00e9p\u00e9ter une instruction, lorsqu'une variable parcourt un ensemble \u00e9num\u00e9rable. while boucle tant que while points < 10 : print(\"continuez !\") Attention, il faut s'assurer qu'on puisse bien sortir de cette boucle. def fonction def welcome(): print(\"bonjour !\") Une fonction peut prendre aucun ou plusieurs param\u00e8tre(s). return renvoi def affine(x): return 3*x + 2 \u00c0 utiliser lorsque la fonction doit renvoyer une valeur. 5. Librairie numpy \u2693\ufe0e 5.0 Importation \u2693\ufe0e La librairie de calcul scientifique numpy peut s'importer de deux mani\u00e8res : M\u00e9thode 1 (d\u00e9conseill\u00e9e) \u2693\ufe0e from numpy import * Cette m\u00e9thode est \u00e0 d\u00e9conseiller car elle importe la totalit\u00e9 de la biblioth\u00e8que. M\u00e9thode 2 (\u00e0 privi\u00e9gier) \u2693\ufe0e import numpy as np Toutes les commandes de numpy devront donc \u00eatre pr\u00e9fix\u00e9es par np. 5.1 Commandes de base \u2693\ufe0e Commande Signification Exemple Commentaires np.e constante d'euler >>> np.e 2.718281828459045 np.pi pi >>> np.pi 3.141592653589793 np.exp() fonction exponentielle >>> np.exp(1) 2.718281828459045 np.log() fonction logarithme >>> np.log(np.e) 1.0 Logarithme de base e np.sqrt() fonction racine carr\u00e9e >>> np.sqrt(2) 1.4142135623730951 np.abs() fonction valeur absolue >>> np.abs(-2) 2 np.floor() fonction partie enti\u00e8re >>> np.floor(4.2) 4.0 5.2 Op\u00e9rations sur les matrices \u2693\ufe0e Commande Signification Exemple Commentaires np.array() cr\u00e9ation d'une matrice >>> np.array([[1,3],[0,5]]) array([[ 1, 3], [0, 5]]) Les op\u00e9rateurs + , - , / , * et ** sont accept\u00e9es mais ne font que des op\u00e9rations terme \u00e0 terme . En particulier, le produit * n'effectue pas un produit matriciel classique. Il faut pour cela utiliser : Commande Signification Exemple Commentaires np.dot() produit matriciel >>> np.dot(A, B) Renvoie le produit matriciel des matrices A et B. np.sum() somme >>> np.sum([[1,3],[0,5]]) 2 Somme des \u00e9l\u00e9ments d'une matrice. np.min() minimum >>> np.min([[1,3],[0,5]]) 0 Mininum des \u00e9l\u00e9ments d'une matrice. np.max() minimum >>> np.max([[1,3],[0,5]]) 5 Maximum des \u00e9l\u00e9ments d'une matrice. np.mean() moyenne >>> np.mean([[1,3],[0,5]]) 2.25 Moyenne des \u00e9l\u00e9ments d'une matrice. np.cumsum() somme cumul\u00e9e >>> np.cumsum([1, 3, 2, 4]) array([ 1, 4, 6, 10]) Somme cumul\u00e9e des \u00e9l\u00e9ments d'une matrice. (ici d'un vecteur) np.median() m\u00e9diane >>> np.median([1, 3, 2, 4]) 2.5 Valeur m\u00e9diane des \u00e9l\u00e9ments d'une matrice. (ici d'un vecteur) np.var() variance >>> np.var([1, 3, 2, 4]) 1.25 Variance des \u00e9l\u00e9ments d'une matrice. (ici d'un vecteur) np.std() \u00e9cart-type >>> np.std([1, 3, 2, 4]) 1.118033988749895 \u00c9cart-type ( standard deviation ) des \u00e9l\u00e9ments d'une matrice. (ici d'un vecteur) 5.3 Sous-librairie random \u2693\ufe0e La partie du programme \u00abSimulation de lois\u00bb utilisera la sous-librairie random de numpy . Elle sera import\u00e9e par : import numpy.random as rd Commande Signification Exemple Commentaires rd.random() nombre al\u00e9atoire dans [0;1[ >>> rd.random() 0.942591321534259 6. Librairie pandas \u2693\ufe0e La librairie pandas sera import\u00e9e par : import pandas as pd Commande Signification Exemple Commentaires mean() moyenne >>> df = pd.DataFrame([2,4,10,3]) >>> df.mean() 0 4.75 dtype: float64 Attention, mean() s'applique sur une dataframe . std() \u00e9cart-type >>> df = pd.DataFrame([2,4,10,3]) >>> df.std() 0 3.593976 dtype: float64 Attention, std() s'applique sur une dataframe . 7. Librairie matplotlib.pyplot \u2693\ufe0e La sous-librairie matplotlib.pyplot sera import\u00e9e par : import matplotlib.pyplot as plt Commande Signification Exemple Commentaires plt.plot() construction d'un graphique >>> plt.plot([1,2,3], [15,12,17]) Cr\u00e9e un graphique (mais ne l'affiche pas) contenant les points (1,15), (2,12) et (3, 17). plt.show() affichage >>> plt.show() Affiche un graphique pr\u00e9c\u00e9demment cr\u00e9\u00e9.","title":"Glossaire"},{"location":"Programme/commandes/#les-commandes-exigibles-du-programme-officiel","text":"","title":"Les commandes exigibles du programme officiel"},{"location":"Programme/commandes/#1-operateurs-arithmetiques-de-base","text":"Commande Signification Exemple Commentaires + addition >>> 5 + 2 7 - soustraction >>> 5 - 2 3 * multiplication >>> 5 * 2 10 / division >>> 7 / 2 3.5 >>> 10 / 2 5.0 Attention, le nombre renvoy\u00e9 par cette division est toujours un nombre \u00e0 virgule. ** puissance >>> 10 ** 3 1000 Attention, ce n'est pas le symbole ^ .","title":"1. Op\u00e9rateurs arithm\u00e9tiques de base"},{"location":"Programme/commandes/#2-operateurs-logiques","text":"Python poss\u00e8de deux mots-cl\u00e9s r\u00e9serv\u00e9s True et False (appel\u00e9s bool\u00e9ens ). Commande Signification Exemple Commentaires and et >>> True and False False or ou >>> True or False True not n\u00e9gation >>> not(True) False","title":"2. Op\u00e9rateurs logiques"},{"location":"Programme/commandes/#3-operateurs-de-comparaison","text":"Ces op\u00e9rateurs de comparaison renvoient syst\u00e9matiquement soit True , soit False . Commande Signification Exemple Commentaires == test d'\u00e9galit\u00e9 >>> 4 + 3 == 8 - 1 True Attention \u00e0 ne pas confondre avec le symbole = qui ne sert qu'\u00e0 l'affectation > test de sup\u00e9riorit\u00e9 >>> 4 > 7 False >= test de sup\u00e9riorit\u00e9 large >>> 7 >= 7 True < test d'inf\u00e9riorit\u00e9 >>> 4 < 7 True <= test d'inf\u00e9riorit\u00e9 large >>> 4 <= 4 True != test de diff\u00e9rence >>> 3 + 2 != 4 True","title":"3. Op\u00e9rateurs de comparaison"},{"location":"Programme/commandes/#4-structures-de-controle","text":"Commande Signification Exemple Commentaires nom = expression affectation >>> a = 1 + 3 >>> a 4 La 1\u00e8re op\u00e9ration effectu\u00e9e est l'\u00e9valuation de la partie \u00e0 droite du = . if si if age >= 18: print(\"majeur\") Attention aux : en fin de ligne, attention \u00e0 l'indentation sous le if . else sinon if age >= 18: print(\"majeur\") else: print(\"mineur\") Attention \u00e0 l'indentation. elif sinon si if age >= 18: print(\"adulte\") elif age >= 14: print(\"ado\") else: print(\"enfant\") elif est une contraction d'un else et d'un if . Il permet de simplifier parfois les tests mais n'est jamais obligatoire. for ... in ... boucle for for n in [3, 5, 9]: print(\"gagn\u00e9 !\") La structure de boucle sert \u00e0 r\u00e9p\u00e9ter une instruction, lorsqu'une variable parcourt un ensemble \u00e9num\u00e9rable. while boucle tant que while points < 10 : print(\"continuez !\") Attention, il faut s'assurer qu'on puisse bien sortir de cette boucle. def fonction def welcome(): print(\"bonjour !\") Une fonction peut prendre aucun ou plusieurs param\u00e8tre(s). return renvoi def affine(x): return 3*x + 2 \u00c0 utiliser lorsque la fonction doit renvoyer une valeur.","title":"4. Structures de contr\u00f4le"},{"location":"Programme/commandes/#5-librairie-numpy","text":"","title":"5. Librairie numpy"},{"location":"Programme/commandes/#50-importation","text":"La librairie de calcul scientifique numpy peut s'importer de deux mani\u00e8res :","title":"5.0 Importation"},{"location":"Programme/commandes/#51-commandes-de-base","text":"Commande Signification Exemple Commentaires np.e constante d'euler >>> np.e 2.718281828459045 np.pi pi >>> np.pi 3.141592653589793 np.exp() fonction exponentielle >>> np.exp(1) 2.718281828459045 np.log() fonction logarithme >>> np.log(np.e) 1.0 Logarithme de base e np.sqrt() fonction racine carr\u00e9e >>> np.sqrt(2) 1.4142135623730951 np.abs() fonction valeur absolue >>> np.abs(-2) 2 np.floor() fonction partie enti\u00e8re >>> np.floor(4.2) 4.0","title":"5.1 Commandes de base"},{"location":"Programme/commandes/#52-operations-sur-les-matrices","text":"Commande Signification Exemple Commentaires np.array() cr\u00e9ation d'une matrice >>> np.array([[1,3],[0,5]]) array([[ 1, 3], [0, 5]]) Les op\u00e9rateurs + , - , / , * et ** sont accept\u00e9es mais ne font que des op\u00e9rations terme \u00e0 terme . En particulier, le produit * n'effectue pas un produit matriciel classique. Il faut pour cela utiliser : Commande Signification Exemple Commentaires np.dot() produit matriciel >>> np.dot(A, B) Renvoie le produit matriciel des matrices A et B. np.sum() somme >>> np.sum([[1,3],[0,5]]) 2 Somme des \u00e9l\u00e9ments d'une matrice. np.min() minimum >>> np.min([[1,3],[0,5]]) 0 Mininum des \u00e9l\u00e9ments d'une matrice. np.max() minimum >>> np.max([[1,3],[0,5]]) 5 Maximum des \u00e9l\u00e9ments d'une matrice. np.mean() moyenne >>> np.mean([[1,3],[0,5]]) 2.25 Moyenne des \u00e9l\u00e9ments d'une matrice. np.cumsum() somme cumul\u00e9e >>> np.cumsum([1, 3, 2, 4]) array([ 1, 4, 6, 10]) Somme cumul\u00e9e des \u00e9l\u00e9ments d'une matrice. (ici d'un vecteur) np.median() m\u00e9diane >>> np.median([1, 3, 2, 4]) 2.5 Valeur m\u00e9diane des \u00e9l\u00e9ments d'une matrice. (ici d'un vecteur) np.var() variance >>> np.var([1, 3, 2, 4]) 1.25 Variance des \u00e9l\u00e9ments d'une matrice. (ici d'un vecteur) np.std() \u00e9cart-type >>> np.std([1, 3, 2, 4]) 1.118033988749895 \u00c9cart-type ( standard deviation ) des \u00e9l\u00e9ments d'une matrice. (ici d'un vecteur)","title":"5.2 Op\u00e9rations sur les matrices"},{"location":"Programme/commandes/#53-sous-librairie-random","text":"La partie du programme \u00abSimulation de lois\u00bb utilisera la sous-librairie random de numpy . Elle sera import\u00e9e par : import numpy.random as rd Commande Signification Exemple Commentaires rd.random() nombre al\u00e9atoire dans [0;1[ >>> rd.random() 0.942591321534259","title":"5.3 Sous-librairie random"},{"location":"Programme/commandes/#6-librairie-pandas","text":"La librairie pandas sera import\u00e9e par : import pandas as pd Commande Signification Exemple Commentaires mean() moyenne >>> df = pd.DataFrame([2,4,10,3]) >>> df.mean() 0 4.75 dtype: float64 Attention, mean() s'applique sur une dataframe . std() \u00e9cart-type >>> df = pd.DataFrame([2,4,10,3]) >>> df.std() 0 3.593976 dtype: float64 Attention, std() s'applique sur une dataframe .","title":"6. Librairie pandas"},{"location":"Programme/commandes/#7-librairie-matplotlibpyplot","text":"La sous-librairie matplotlib.pyplot sera import\u00e9e par : import matplotlib.pyplot as plt Commande Signification Exemple Commentaires plt.plot() construction d'un graphique >>> plt.plot([1,2,3], [15,12,17]) Cr\u00e9e un graphique (mais ne l'affiche pas) contenant les points (1,15), (2,12) et (3, 17). plt.show() affichage >>> plt.show() Affiche un graphique pr\u00e9c\u00e9demment cr\u00e9\u00e9.","title":"7. Librairie matplotlib.pyplot"},{"location":"TD01/TD01/","text":"TD01 : R\u00e9visions des structures \u00e9l\u00e9mentaires \u2693\ufe0e Lien pour ouvrir une console Python dans un nouvel onglet 1. Affectations \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction On consid\u00e8re deux variables a et b , valant respectivement 3 et 5. >>> a = 3 >>> b = 5 Proposer une suite d'instructions qui \u00e9change les valeurs de a et de b . M\u00e9thode universelle, avec une variable temporaire : >>> temp = a >>> a = b >>> b = temp M\u00e9thode rapide (sp\u00e9cifique \u00e0 Python) : >>> a , b = b , a En savoir plus sur les variables 2. Boucles born\u00e9es : boucles for \u2693\ufe0e Exercice 2 \u00c9nonc\u00e9 Correction \u00c9crire un code affichant 13 fois le mot \"bonjour\" (sans copier-coller, \u00e9videmment...) . 1 2 for k in range ( 13 ): print ( \"bonjour\" ) En savoir plus sur la boucle for 3. Boucles non born\u00e9es : boucles while \u2693\ufe0e Exercice 3 \u00c9nonc\u00e9 Correction Copier et ex\u00e9cuter le code ci-dessous : 1 2 3 4 5 6 somme = 0 k = 0 while somme < 3 : k = k + 1 #(1) somme = somme + 1 / k #(2) print ( k ) Peut aussi s'\u00e9crire plus rapidement avec k += 1 ou somme += 1 / k Expliquer la signification de la valeur affich\u00e9e. Vous pouvez d\u00e9tailler le fonctionnement de ce code gr\u00e2ce \u00e0 PythonTutor 11 est la plus petite valeur de \\(k\\) pour laquelle la somme \\(1 + \\frac{1}{2} + \\frac{1}{3} + \\dots + \\frac{1}{k}\\) devient sup\u00e9rieure ou \u00e9gale \u00e0 3. En savoir plus la boucle while Exercice 4 \u00c9nonc\u00e9 Correction Un capital de 10 000 \u20ac est plac\u00e9 au taux annuel de 4 %. \u00c9crire le code permettant d'afficher l'ann\u00e9e \u00e0 partir de laquelle le capital va d\u00e9passer 14 000 \u20ac. 1 2 3 4 5 6 capital = 10000 annee = 0 while capital < 14000 : annee += 1 capital = capital * 1.04 #(1) print ( annee ) ou capital *= 1.04 4. Fonctions / tests \u2693\ufe0e Exercice 5 \u00c9nonc\u00e9 Correction Quel est l'autre nom de la fonction mystere d\u00e9finie dans le code ci-dessous ? 1 2 3 4 5 def mystere ( x ): if x > 0 : return x else : return - x C'est la fonction math\u00e9matique valeur absolue . En savoir plus sur les fonctions Exercice 6 \u00c9nonc\u00e9 Correction En vous inspirant de l'exercice pr\u00e9c\u00e9dent, \u00e9crire une fonction maximum qui prend en param\u00e8tres deux nombres a et b et qui renvoie le plus grand de ces deux nombres. Exemple d'utilisation : >>> maximum ( 4 , 7 ) 7 1 2 3 4 5 def maximum ( a , b ): if a > b : return a else : return b 5. Librairie numpy \u2693\ufe0e Exercice 7 \u00c9nonc\u00e9 Afficher une suite de 50 nombres (pseudo-)al\u00e9atoires dans l'intervalle \\([0;1[\\) . Exercice 8 \u00c9nonc\u00e9 Que fait le code ci-dessous ? import numpy as np import numpy.random as rd def mystere ( val ): n = 100 c = 0 j = 0 while j < n : x = 1 + np . floor ( 6 * rd . random ()) y = 1 + np . floor ( 6 * rd . random ()) if x + y == val : c += 1 j += 1 return c / n Exercice 9 \u00c9nonc\u00e9 \u00c9crire un code o\u00f9 l'utilisateur doit deviner un nombre choisi al\u00e9atoirement par l'ordinateur entre 1 et 100. L'utilisateur devra \u00eatre guid\u00e9 apr\u00e8s chaque proposition par les instructions \u00abtrop grand\u00bb ou \u00abtrop petit\u00bb . aide : 1 2 3 4 5 6 7 import numpy as np import numpy.random as rd nb_secret = ... prop = int ( input ( \"proposition ? \" )) while ...","title":"TD01 : R\u00e9visions des structures \u00e9l\u00e9mentaires"},{"location":"TD01/TD01/#td01-revisions-des-structures-elementaires","text":"Lien pour ouvrir une console Python dans un nouvel onglet","title":"TD01 : R\u00e9visions des structures \u00e9l\u00e9mentaires"},{"location":"TD01/TD01/#1-affectations","text":"Exercice 1 \u00c9nonc\u00e9 Correction On consid\u00e8re deux variables a et b , valant respectivement 3 et 5. >>> a = 3 >>> b = 5 Proposer une suite d'instructions qui \u00e9change les valeurs de a et de b . M\u00e9thode universelle, avec une variable temporaire : >>> temp = a >>> a = b >>> b = temp M\u00e9thode rapide (sp\u00e9cifique \u00e0 Python) : >>> a , b = b , a En savoir plus sur les variables","title":"1. Affectations"},{"location":"TD01/TD01/#2-boucles-bornees-boucles-for","text":"Exercice 2 \u00c9nonc\u00e9 Correction \u00c9crire un code affichant 13 fois le mot \"bonjour\" (sans copier-coller, \u00e9videmment...) . 1 2 for k in range ( 13 ): print ( \"bonjour\" ) En savoir plus sur la boucle for","title":"2. Boucles born\u00e9es : boucles for"},{"location":"TD01/TD01/#3-boucles-non-bornees-boucles-while","text":"Exercice 3 \u00c9nonc\u00e9 Correction Copier et ex\u00e9cuter le code ci-dessous : 1 2 3 4 5 6 somme = 0 k = 0 while somme < 3 : k = k + 1 #(1) somme = somme + 1 / k #(2) print ( k ) Peut aussi s'\u00e9crire plus rapidement avec k += 1 ou somme += 1 / k Expliquer la signification de la valeur affich\u00e9e. Vous pouvez d\u00e9tailler le fonctionnement de ce code gr\u00e2ce \u00e0 PythonTutor 11 est la plus petite valeur de \\(k\\) pour laquelle la somme \\(1 + \\frac{1}{2} + \\frac{1}{3} + \\dots + \\frac{1}{k}\\) devient sup\u00e9rieure ou \u00e9gale \u00e0 3. En savoir plus la boucle while Exercice 4 \u00c9nonc\u00e9 Correction Un capital de 10 000 \u20ac est plac\u00e9 au taux annuel de 4 %. \u00c9crire le code permettant d'afficher l'ann\u00e9e \u00e0 partir de laquelle le capital va d\u00e9passer 14 000 \u20ac. 1 2 3 4 5 6 capital = 10000 annee = 0 while capital < 14000 : annee += 1 capital = capital * 1.04 #(1) print ( annee ) ou capital *= 1.04","title":"3. Boucles non born\u00e9es : boucles while"},{"location":"TD01/TD01/#4-fonctions-tests","text":"Exercice 5 \u00c9nonc\u00e9 Correction Quel est l'autre nom de la fonction mystere d\u00e9finie dans le code ci-dessous ? 1 2 3 4 5 def mystere ( x ): if x > 0 : return x else : return - x C'est la fonction math\u00e9matique valeur absolue . En savoir plus sur les fonctions Exercice 6 \u00c9nonc\u00e9 Correction En vous inspirant de l'exercice pr\u00e9c\u00e9dent, \u00e9crire une fonction maximum qui prend en param\u00e8tres deux nombres a et b et qui renvoie le plus grand de ces deux nombres. Exemple d'utilisation : >>> maximum ( 4 , 7 ) 7 1 2 3 4 5 def maximum ( a , b ): if a > b : return a else : return b","title":"4. Fonctions / tests"},{"location":"TD01/TD01/#5-librairie-numpy","text":"Exercice 7 \u00c9nonc\u00e9 Afficher une suite de 50 nombres (pseudo-)al\u00e9atoires dans l'intervalle \\([0;1[\\) . Exercice 8 \u00c9nonc\u00e9 Que fait le code ci-dessous ? import numpy as np import numpy.random as rd def mystere ( val ): n = 100 c = 0 j = 0 while j < n : x = 1 + np . floor ( 6 * rd . random ()) y = 1 + np . floor ( 6 * rd . random ()) if x + y == val : c += 1 j += 1 return c / n Exercice 9 \u00c9nonc\u00e9 \u00c9crire un code o\u00f9 l'utilisateur doit deviner un nombre choisi al\u00e9atoirement par l'ordinateur entre 1 et 100. L'utilisateur devra \u00eatre guid\u00e9 apr\u00e8s chaque proposition par les instructions \u00abtrop grand\u00bb ou \u00abtrop petit\u00bb . aide : 1 2 3 4 5 6 7 import numpy as np import numpy.random as rd nb_secret = ... prop = int ( input ( \"proposition ? \" )) while ...","title":"5. Librairie numpy"},{"location":"TD02/TD02/","text":"TD02 : Premi\u00e8res simulations \u2693\ufe0e Lien pour ouvrir une console Python dans un nouvel onglet 1. Rappels \u2693\ufe0e Chaque langage de programmation permet de simuler du hasard. Ce hasard n'est que du pseudo-hasard , un ordinateur \u00e9tant par d\u00e9finition un objet d\u00e9terministe, effectuant de mani\u00e8re fid\u00e8le et r\u00e9p\u00e9titive des op\u00e9rations ordonn\u00e9es par le programmeur. Nous allons travailler avec le g\u00e9n\u00e9rateur pseudo-al\u00e9atoire (GPA) du module random de la biblioth\u00e8que numpy . Exemples >>> import numpy as np >>> import numpy.random as rd >>> rd . random () 0.5488135039273248 >>> rd . random () 0.7151893663724195 >>> rd . random () 0.6027633760716439 >>> rd . seed ( 0 ) # r\u00e9initialisation de la graine du GPA >>> rd . random () 0.5488135039273248 # les m\u00eames nombres reviennent... >>> rd . random () 0.7151893663724195 2. Lancers de d\u00e9s \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Que fait le code ci-dessous ? import numpy as np import numpy.random as rd def mystere ( val ): n = 100 c = 0 j = 0 while j < n : x = 1 + np . floor ( 6 * rd . random ()) y = 1 + np . floor ( 6 * rd . random ()) if x + y == val : c += 1 j += 1 return c / n Remarque : l'instruction np . floor ( 6 * rd . random ()) aurait pu avantageusement \u00eatre remplac\u00e9e par rd . randint ( 1 , 6 ) . 3. Utilisation de matplotlib \u2693\ufe0e matplotlib est une biblioth\u00e8que permettant le trac\u00e9 de graphiques. Elle sera syst\u00e9matiquement import\u00e9e par : import matplotlib.pyplot as plt Le code : 1 2 3 4 5 import matplotlib.pyplot as plt X = [ 0 , 1 , 3 , 6 ] Y = [ 12 , 10 , 7 , 15 ] plt . plot ( X , Y , 'ro' ) # r pour red, o pour un cercle. voir https://matplotlib.org/api/markers_api.html plt . show () fait appara\u00eetre le graphique suivant On y retrouve les points de coordonn\u00e9es (0,12), (1,10), ..., (6,15). On aurait aussi pu tracer la ligne bris\u00e9e les reliant : 1 2 3 4 5 6 import matplotlib.pyplot as plt plt . clf () # pour effacer les anciens graphiques X = [ 0 , 1 , 3 , 6 ] Y = [ 12 , 10 , 7 , 15 ] plt . plot ( X , Y , 'b-' ) # b pour blue, - pour des segments plt . show () Ou bien encore un diagramme en barres : 1 2 3 4 5 6 import matplotlib.pyplot as plt plt . clf () # pour effacer les anciens graphiques X = [ 0 , 1 , 3 , 6 ] Y = [ 12 , 10 , 7 , 15 ] plt . bar ( X , Y ) plt . show () 4. Construire une liste \u2693\ufe0e Nous avons vu que matplotlib n\u00e9cessite la cr\u00e9ation de deux listes X et Y contenant respectivement les abscisses et les ordonn\u00e9es qui nous int\u00e9ressent. Comment construire ces listes ? De nombreuses m\u00e9thodes existent en Python. 4.1 Construire une liste de nombres entiers cons\u00e9cutifs \u2693\ufe0e Ceci est n\u00e9cessaire pour construire la liste des abscisses. On utilisera alors l'instruction arange de numpy : np.arange(n1,n2) : renvoie un tableau (qu'on consid\u00e8rera comme un liste) contenant tous les entiers de n1 (inclus) \u00e0 n2 ( exclus ). Tr\u00e8s souvent utilis\u00e9 pour construire la liste X . Exemple : >>> np . arange ( 1 , 7 ) array ([ 1 , 2 , 3 , 4 , 5 , 6 ]) 4.2 Construire une liste pleine de z\u00e9ros \u2693\ufe0e L'instruction zeros de numpy permet de construire un tableau plein de z\u00e9ros. Exemple : >>> np . zeros ( 6 ) array ([ 0. , 0. , 0. , 0. , 0. , 0. ]) Mais pourquoi un tableau plein de z\u00e9ros ? Pour pouvoir le remplir ensuite avec une boucle : Exemple : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import numpy as np import matplotlib.pyplot as plt X = np . arange ( 10 ) Y = np . zeros ( 10 ) def f ( x ): return np . log ( x + 1 ) for k in range ( 10 ): Y [ k ] = f ( k ) plt . clf () plt . plot ( X , Y , '-' ) plt . show () 4.3 Construire une liste directement (m\u00e9thode par compr\u00e9hension ) \u2693\ufe0e C'est de loin la m\u00e9thode la plus \u00e9l\u00e9gante. Elle consiste \u00e0 \u00e9crire \u00e0 l'int\u00e9rieur de la liste la formule de cr\u00e9ation de celle-ci. Exemple : >>> lst = [ k ** 2 for k in range ( 6 )] >>> lst [ 0 , 1 , 4 , 9 , 16 , 25 ] Le code pr\u00e9c\u00e9dent de trac\u00e9 de la fonction \\(\\ln(x+1)\\) peut donc s'\u00e9crire aussi : 1 2 3 4 5 6 7 8 9 10 11 import numpy as np def f ( x ): return np . log ( x + 1 ) X = np . arange ( 10 ) Y = [ f ( k ) for k in X ] plt . clf () plt . plot ( X , Y , '-' ) plt . show () Exercice 2 \u00c9nonc\u00e9 Tracer le diagramme en barres de la fonction mystere de l'exercice 1, pour des valeurs allant entre 0 et 12. 5. Retour sur le while . \u2693\ufe0e Exercice 3 \u00c9nonc\u00e9 \u00c9crire un code o\u00f9 l'utilisateur doit deviner un nombre choisi al\u00e9atoirement par l'ordinateur entre 1 et 100. L'utilisateur devra \u00eatre guid\u00e9 apr\u00e8s chaque proposition par les instructions \u00abtrop grand\u00bb ou \u00abtrop petit\u00bb . aide : 1 2 3 4 5 6 7 8 import numpy as np import numpy.random as rd nb_secret = ... prop = int ( input ( \"proposition ? \" )) while ... ... 6. Simulations d'une exp\u00e9rience de Bernoulli \u2693\ufe0e Comme l'instruction rd.random() renvoie un nombre al\u00e9atoire entre 0 et 1, une variable al\u00e9atoire suivant une loi de probabilit\u00e9 de Bernoulli de param\u00e8tre \\(p\\) peut \u00eatre simul\u00e9e par un test d'appartenance de rd.random() \u00e0 l'intervalle : \\([0;p]\\) (succ\u00e8s) ou \\(]p;1]\\) (\u00e9chec) : Exercice 4 \u00c9nonc\u00e9 Correction Q1 Correction Q2 On consid\u00e8re une urne comportant 3 boules blanches et 5 boules noires. Cr\u00e9er une fonction tirage() renvoyant la valeur 1 si la boule tir\u00e9e est blanche, et la valeur 0 si la boule tir\u00e9e est noire. Simuler 100 000 fois cette exp\u00e9rience al\u00e9atoire et afficher la fr\u00e9quence d'apparition d'une boule blanche. 1 2 3 4 5 6 7 8 9 import numpy as np import numpy.random as rd def tirage (): val_alea = rd . random () if val_alea < 3 / 8 : return 1 else : return 0 1 2 3 4 5 6 nb_tirages = 10 ** 5 somme_blanches = 0 for k in range ( nb_tirages ): somme_blanches += tirage () print ( somme_blanches / nb_tirages ) 7. Retour sur les suites \u2693\ufe0e Exercice 5 extrait du sujet 0 Ecricome \u00c9nonc\u00e9 On consid\u00e8re la suite \\((u_n)_{n \\in \\mathbb{N}^*}\\) d\u00e9finie par \\(u_1=\\dfrac{2}{3}\\) et, \\(\\forall n \\in \\mathbb{N}^*, u_{n+1}=\\dfrac{n+1}{3n}u_n\\) . Calculer \\(u_1\\) et \\(u_3\\) . Donner les r\u00e9sultats sous forme de fraction irr\u00e9ductible. Compl\u00e9ter la fonction Python ci-desous qui prend en entr\u00e9e la valeur \\(n\\) et renvoie la valeur de \\(u_n\\) . 1 2 3 4 5 def suite ( n ): u = 2 / 3 for k in range ( 1 , n ): u = ... return u Exercice 6 inspir\u00e9 du sujet Ecricome 2019 \u00c9nonc\u00e9 Soit \\(g\\) la fonction num\u00e9rique r\u00e9elle d\u00e9finie sur l'intervalle \\(]0;+\\infty[\\) par : \\[ g(x)=2x-1+\\ln \\left( \\frac{x}{x+1} \\right) \\] Q1. \u00c9crire en Python la fonction \\(g\\) . Le script Python ci-dessous construit un vecteur ligne contenant les 50 premiers termes de la suite \\((u_n)_{n \\geqslant 1}\\) . 1 2 3 4 5 6 7 8 9 10 u = np . zeros ( 50 ) for n in range ( 1 , 50 ): u [ n ] = 2 * n - 1 - g ( n ) S = np . cumsum ( u ) X = np . arange ( 50 ) plt . plot ( X , S ) plt . show () Q2. Interpr\u00e9ter le contenu de la ligne 6 dans le contexte de l'\u00e9nonc\u00e9. Q3. Ex\u00e9cutez le script pr\u00e9c\u00e9dent et observez le graphique obtenu. Q4. Sur ce m\u00eame graphique, tracez la courbe repr\u00e9sentative de la fonction \\(\\ln\\) .","title":"TD02 : Premi\u00e8res simulations"},{"location":"TD02/TD02/#td02-premieres-simulations","text":"Lien pour ouvrir une console Python dans un nouvel onglet","title":"TD02 : Premi\u00e8res simulations"},{"location":"TD02/TD02/#1-rappels","text":"Chaque langage de programmation permet de simuler du hasard. Ce hasard n'est que du pseudo-hasard , un ordinateur \u00e9tant par d\u00e9finition un objet d\u00e9terministe, effectuant de mani\u00e8re fid\u00e8le et r\u00e9p\u00e9titive des op\u00e9rations ordonn\u00e9es par le programmeur. Nous allons travailler avec le g\u00e9n\u00e9rateur pseudo-al\u00e9atoire (GPA) du module random de la biblioth\u00e8que numpy . Exemples >>> import numpy as np >>> import numpy.random as rd >>> rd . random () 0.5488135039273248 >>> rd . random () 0.7151893663724195 >>> rd . random () 0.6027633760716439 >>> rd . seed ( 0 ) # r\u00e9initialisation de la graine du GPA >>> rd . random () 0.5488135039273248 # les m\u00eames nombres reviennent... >>> rd . random () 0.7151893663724195","title":"1. Rappels"},{"location":"TD02/TD02/#2-lancers-de-des","text":"Exercice 1 \u00c9nonc\u00e9 Que fait le code ci-dessous ? import numpy as np import numpy.random as rd def mystere ( val ): n = 100 c = 0 j = 0 while j < n : x = 1 + np . floor ( 6 * rd . random ()) y = 1 + np . floor ( 6 * rd . random ()) if x + y == val : c += 1 j += 1 return c / n Remarque : l'instruction np . floor ( 6 * rd . random ()) aurait pu avantageusement \u00eatre remplac\u00e9e par rd . randint ( 1 , 6 ) .","title":"2. Lancers de d\u00e9s"},{"location":"TD02/TD02/#3-utilisation-de-matplotlib","text":"matplotlib est une biblioth\u00e8que permettant le trac\u00e9 de graphiques. Elle sera syst\u00e9matiquement import\u00e9e par : import matplotlib.pyplot as plt Le code : 1 2 3 4 5 import matplotlib.pyplot as plt X = [ 0 , 1 , 3 , 6 ] Y = [ 12 , 10 , 7 , 15 ] plt . plot ( X , Y , 'ro' ) # r pour red, o pour un cercle. voir https://matplotlib.org/api/markers_api.html plt . show () fait appara\u00eetre le graphique suivant On y retrouve les points de coordonn\u00e9es (0,12), (1,10), ..., (6,15). On aurait aussi pu tracer la ligne bris\u00e9e les reliant : 1 2 3 4 5 6 import matplotlib.pyplot as plt plt . clf () # pour effacer les anciens graphiques X = [ 0 , 1 , 3 , 6 ] Y = [ 12 , 10 , 7 , 15 ] plt . plot ( X , Y , 'b-' ) # b pour blue, - pour des segments plt . show () Ou bien encore un diagramme en barres : 1 2 3 4 5 6 import matplotlib.pyplot as plt plt . clf () # pour effacer les anciens graphiques X = [ 0 , 1 , 3 , 6 ] Y = [ 12 , 10 , 7 , 15 ] plt . bar ( X , Y ) plt . show ()","title":"3. Utilisation de matplotlib"},{"location":"TD02/TD02/#4-construire-une-liste","text":"Nous avons vu que matplotlib n\u00e9cessite la cr\u00e9ation de deux listes X et Y contenant respectivement les abscisses et les ordonn\u00e9es qui nous int\u00e9ressent. Comment construire ces listes ? De nombreuses m\u00e9thodes existent en Python.","title":"4. Construire une liste"},{"location":"TD02/TD02/#41-construire-une-liste-de-nombres-entiers-consecutifs","text":"Ceci est n\u00e9cessaire pour construire la liste des abscisses. On utilisera alors l'instruction arange de numpy : np.arange(n1,n2) : renvoie un tableau (qu'on consid\u00e8rera comme un liste) contenant tous les entiers de n1 (inclus) \u00e0 n2 ( exclus ). Tr\u00e8s souvent utilis\u00e9 pour construire la liste X . Exemple : >>> np . arange ( 1 , 7 ) array ([ 1 , 2 , 3 , 4 , 5 , 6 ])","title":"4.1 Construire une liste de nombres entiers cons\u00e9cutifs"},{"location":"TD02/TD02/#42-construire-une-liste-pleine-de-zeros","text":"L'instruction zeros de numpy permet de construire un tableau plein de z\u00e9ros. Exemple : >>> np . zeros ( 6 ) array ([ 0. , 0. , 0. , 0. , 0. , 0. ]) Mais pourquoi un tableau plein de z\u00e9ros ? Pour pouvoir le remplir ensuite avec une boucle : Exemple : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import numpy as np import matplotlib.pyplot as plt X = np . arange ( 10 ) Y = np . zeros ( 10 ) def f ( x ): return np . log ( x + 1 ) for k in range ( 10 ): Y [ k ] = f ( k ) plt . clf () plt . plot ( X , Y , '-' ) plt . show ()","title":"4.2 Construire une liste pleine de z\u00e9ros"},{"location":"TD02/TD02/#43-construire-une-liste-directement-methode-par-comprehension","text":"C'est de loin la m\u00e9thode la plus \u00e9l\u00e9gante. Elle consiste \u00e0 \u00e9crire \u00e0 l'int\u00e9rieur de la liste la formule de cr\u00e9ation de celle-ci. Exemple : >>> lst = [ k ** 2 for k in range ( 6 )] >>> lst [ 0 , 1 , 4 , 9 , 16 , 25 ] Le code pr\u00e9c\u00e9dent de trac\u00e9 de la fonction \\(\\ln(x+1)\\) peut donc s'\u00e9crire aussi : 1 2 3 4 5 6 7 8 9 10 11 import numpy as np def f ( x ): return np . log ( x + 1 ) X = np . arange ( 10 ) Y = [ f ( k ) for k in X ] plt . clf () plt . plot ( X , Y , '-' ) plt . show () Exercice 2 \u00c9nonc\u00e9 Tracer le diagramme en barres de la fonction mystere de l'exercice 1, pour des valeurs allant entre 0 et 12.","title":"4.3 Construire une liste directement (m\u00e9thode par compr\u00e9hension)"},{"location":"TD02/TD02/#5-retour-sur-le-while","text":"Exercice 3 \u00c9nonc\u00e9 \u00c9crire un code o\u00f9 l'utilisateur doit deviner un nombre choisi al\u00e9atoirement par l'ordinateur entre 1 et 100. L'utilisateur devra \u00eatre guid\u00e9 apr\u00e8s chaque proposition par les instructions \u00abtrop grand\u00bb ou \u00abtrop petit\u00bb . aide : 1 2 3 4 5 6 7 8 import numpy as np import numpy.random as rd nb_secret = ... prop = int ( input ( \"proposition ? \" )) while ... ...","title":"5. Retour sur le while."},{"location":"TD02/TD02/#6-simulations-dune-experience-de-bernoulli","text":"Comme l'instruction rd.random() renvoie un nombre al\u00e9atoire entre 0 et 1, une variable al\u00e9atoire suivant une loi de probabilit\u00e9 de Bernoulli de param\u00e8tre \\(p\\) peut \u00eatre simul\u00e9e par un test d'appartenance de rd.random() \u00e0 l'intervalle : \\([0;p]\\) (succ\u00e8s) ou \\(]p;1]\\) (\u00e9chec) : Exercice 4 \u00c9nonc\u00e9 Correction Q1 Correction Q2 On consid\u00e8re une urne comportant 3 boules blanches et 5 boules noires. Cr\u00e9er une fonction tirage() renvoyant la valeur 1 si la boule tir\u00e9e est blanche, et la valeur 0 si la boule tir\u00e9e est noire. Simuler 100 000 fois cette exp\u00e9rience al\u00e9atoire et afficher la fr\u00e9quence d'apparition d'une boule blanche. 1 2 3 4 5 6 7 8 9 import numpy as np import numpy.random as rd def tirage (): val_alea = rd . random () if val_alea < 3 / 8 : return 1 else : return 0 1 2 3 4 5 6 nb_tirages = 10 ** 5 somme_blanches = 0 for k in range ( nb_tirages ): somme_blanches += tirage () print ( somme_blanches / nb_tirages )","title":"6.  Simulations d'une exp\u00e9rience de Bernoulli"},{"location":"TD02/TD02/#7-retour-sur-les-suites","text":"Exercice 5 extrait du sujet 0 Ecricome \u00c9nonc\u00e9 On consid\u00e8re la suite \\((u_n)_{n \\in \\mathbb{N}^*}\\) d\u00e9finie par \\(u_1=\\dfrac{2}{3}\\) et, \\(\\forall n \\in \\mathbb{N}^*, u_{n+1}=\\dfrac{n+1}{3n}u_n\\) . Calculer \\(u_1\\) et \\(u_3\\) . Donner les r\u00e9sultats sous forme de fraction irr\u00e9ductible. Compl\u00e9ter la fonction Python ci-desous qui prend en entr\u00e9e la valeur \\(n\\) et renvoie la valeur de \\(u_n\\) . 1 2 3 4 5 def suite ( n ): u = 2 / 3 for k in range ( 1 , n ): u = ... return u Exercice 6 inspir\u00e9 du sujet Ecricome 2019 \u00c9nonc\u00e9 Soit \\(g\\) la fonction num\u00e9rique r\u00e9elle d\u00e9finie sur l'intervalle \\(]0;+\\infty[\\) par : \\[ g(x)=2x-1+\\ln \\left( \\frac{x}{x+1} \\right) \\] Q1. \u00c9crire en Python la fonction \\(g\\) . Le script Python ci-dessous construit un vecteur ligne contenant les 50 premiers termes de la suite \\((u_n)_{n \\geqslant 1}\\) . 1 2 3 4 5 6 7 8 9 10 u = np . zeros ( 50 ) for n in range ( 1 , 50 ): u [ n ] = 2 * n - 1 - g ( n ) S = np . cumsum ( u ) X = np . arange ( 50 ) plt . plot ( X , S ) plt . show () Q2. Interpr\u00e9ter le contenu de la ligne 6 dans le contexte de l'\u00e9nonc\u00e9. Q3. Ex\u00e9cutez le script pr\u00e9c\u00e9dent et observez le graphique obtenu. Q4. Sur ce m\u00eame graphique, tracez la courbe repr\u00e9sentative de la fonction \\(\\ln\\) .","title":"7. Retour sur les suites"},{"location":"TD03/TD03/","text":"TD03 : Retour sur les simulations \u2693\ufe0e Lien pour ouvrir une console Python dans un nouvel onglet 1. Rappels sur les exp\u00e9riences de Bernoulli \u2693\ufe0e rappel de la syntaxe d'importation de numpy.random 1 2 import numpy as np import numpy.random as rd Comme l'instruction rd.random() renvoie un nombre al\u00e9atoire entre 0 et 1, une variable al\u00e9atoire suivant une loi de probabilit\u00e9 de Bernoulli de param\u00e8tre \\(p\\) peut \u00eatre simul\u00e9e par un test d'appartenance de rd.random() \u00e0 l'intervalle : \\([0;p]\\) (succ\u00e8s) ou \\(]p;1]\\) (\u00e9chec) : Exercice 1 \u00c9nonc\u00e9 Correction Q1 Correction Q2 On consid\u00e8re une urne comportant 3 boules blanches et 5 boules noires. Cr\u00e9er une fonction tirage() renvoyant la valeur 1 si la boule tir\u00e9e est blanche, et la valeur 0 si la boule tir\u00e9e est noire. Simuler 100 000 fois cette exp\u00e9rience al\u00e9atoire et afficher la fr\u00e9quence d'apparition d'une boule blanche. 1 2 3 4 5 6 7 8 9 import numpy as np import numpy.random as rd def tirage (): val_alea = rd . random () if val_alea < 3 / 8 : return 1 else : return 0 1 2 3 4 5 6 nb_tirages = 10 ** 5 somme_blanches = 0 for k in range ( nb_tirages ): somme_blanches += tirage () print ( somme_blanches / nb_tirages ) Exercice 2 inspir\u00e9 par Ecricome 2018 \u00c9nonc\u00e9 Correction Q1 Correction Q2 Correction Q3 On consid\u00e8re une urne \\(U\\) contenant deux boules blanches et une boule noire indiscernables au toucher, ainsi qu\u2019une urne \\(V\\) contenant une boule blanche et trois boules noires, elles aussi indiscernables au toucher. On effectue une suite de tirages d\u2019une boule dans ces urnes en proc\u00e9dant comme suit : le premier tirage a lieu dans l\u2019urne U ; tous les tirages s\u2019effectuent avec remise de la boule pioch\u00e9e dans l\u2019urne dont elle provient; si l\u2019on pioche une boule blanche lors d\u2019un tirage, le tirage suivant a lieu dans l\u2019autre urne; si l\u2019on pioche une boule noire lors d\u2019un tirage, le tirage suivant a lieu dans la m\u00eame urne. Pour tout entier naturel non nul \\(n\\) , on note \\(X_n\\) la variable al\u00e9atoire \u00e9gale au nombre de boules blanches pioch\u00e9es au cours des \\(n\\) premiers tirages. On rappelle qu\u2019en Python, l\u2019instruction rd.randint(1,k) renvoie un entier al\u00e9atoire compris entre 1 et k-1 . Q1. Recopier et compl\u00e9ter les lignes \u00e0 pointill\u00e9s du script Python ci-dessous afin qu\u2019il simule la variable al\u00e9atoire \\(X_2\\) : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import numpy as np import numpy.random as rd def simulation (): tirage1 = rd . randint ( 1 , 4 ) if tirage1 < 3 : res1 = 1 tirage2 = rd . randint ( 1 , 5 ) if tirage2 == 1 : res2 = 1 else : res2 = 0 else : res1 = 0 tirage2 = ... if tirage2 < 3 : res2 = ... else : res2 = ... X = ... + ... return X Q2. \u00c9crire une fonction freq(n) qui renvoie la valeur moyenne du nombre de boules blanches tir\u00e9es sur n exp\u00e9riences r\u00e9alis\u00e9es. Q3. En d\u00e9duire \\(E(X_2)\\) et retrouver ce r\u00e9sultat par un calcul th\u00e9orique. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import numpy as np import numpy.random as rd def simulation (): tirage1 = rd . randint ( 1 , 4 ) if tirage1 < 3 : res1 = 1 tirage2 = rd . randint ( 1 , 5 ) if tirage2 == 1 : res2 = 1 else : res2 = 0 else : res1 = 0 tirage2 = rd . randint ( 1 , 4 ) if tirage2 < 3 : res2 = 1 else : res2 = 0 X = res1 + res2 return X 1 2 3 4 5 def freq ( n ): compteur = 0 for k in range ( n ): compteur += simulation () return compteur / n Exp\u00e9rimentaliment : >>> freq ( 10 ** 6 ) 1.055416 Th\u00e9oriquement, en faisant un arbre de probalit\u00e9s, \\[E(X_2) = 2 \\times \\dfrac{2}{6} + 1 \\times \\dfrac{1}{2} + 1 \\times \\dfrac{2}{9} = \\dfrac{57}{54}\\] 2. Retour sur le while . \u2693\ufe0e Exercice 3 \u00c9nonc\u00e9 \u00c9crire un code o\u00f9 l'utilisateur doit deviner un nombre choisi al\u00e9atoirement par l'ordinateur entre 1 et 100. L'utilisateur devra \u00eatre guid\u00e9 apr\u00e8s chaque proposition par les instructions \u00abtrop grand\u00bb ou \u00abtrop petit\u00bb . aide : 1 2 3 4 5 6 7 8 import numpy as np import numpy.random as rd nb_secret = ... prop = int ( input ( \"proposition ? \" )) while ... ... 3. Retour sur les suites \u2693\ufe0e Exercice 4 extrait du sujet 0 Ecricome \u00c9nonc\u00e9 On consid\u00e8re la suite \\((u_n)_{n \\in \\mathbb{N}^*}\\) d\u00e9finie par \\(u_1=\\dfrac{2}{3}\\) et, \\(\\forall n \\in \\mathbb{N}^*, u_{n+1}=\\dfrac{n+1}{3n}u_n\\) . Calculer \\(u_1\\) et \\(u_3\\) . Donner les r\u00e9sultats sous forme de fraction irr\u00e9ductible. Compl\u00e9ter la fonction Python ci-desous qui prend en entr\u00e9e la valeur \\(n\\) et renvoie la valeur de \\(u_n\\) . 1 2 3 4 5 def suite ( n ): u = 2 / 3 for k in range ( 1 , n ): u = ... return u Exercice 5 inspir\u00e9 du sujet Ecricome 2019 \u00c9nonc\u00e9 Soit \\(g\\) la fonction num\u00e9rique r\u00e9elle d\u00e9finie sur l'intervalle \\(]0;+\\infty[\\) par : \\[ g(x)=2x-1+\\ln \\left( \\frac{x}{x+1} \\right) \\] Q1. \u00c9crire en Python la fonction \\(g\\) . Le script Python ci-dessous construit un vecteur ligne contenant les 50 premiers termes de la suite \\((u_n)_{n \\geqslant 1}\\) . 1 2 3 4 5 6 7 8 9 10 u = np . zeros ( 50 ) for n in range ( 1 , 50 ): u [ n ] = 2 * n - 1 - g ( n ) S = np . cumsum ( u ) X = np . arange ( 50 ) plt . plot ( X , S ) plt . show () Q2. Interpr\u00e9ter le contenu de la ligne 6 dans le contexte de l'\u00e9nonc\u00e9. Q3. Ex\u00e9cutez le script pr\u00e9c\u00e9dent et observez le graphique obtenu. Q4. Sur ce m\u00eame graphique, tracez la courbe repr\u00e9sentative de la fonction \\(\\ln\\) .","title":"TD03 : Retour sur les simulations"},{"location":"TD03/TD03/#td03-retour-sur-les-simulations","text":"Lien pour ouvrir une console Python dans un nouvel onglet","title":"TD03 : Retour sur les simulations"},{"location":"TD03/TD03/#1-rappels-sur-les-experiences-de-bernoulli","text":"rappel de la syntaxe d'importation de numpy.random 1 2 import numpy as np import numpy.random as rd Comme l'instruction rd.random() renvoie un nombre al\u00e9atoire entre 0 et 1, une variable al\u00e9atoire suivant une loi de probabilit\u00e9 de Bernoulli de param\u00e8tre \\(p\\) peut \u00eatre simul\u00e9e par un test d'appartenance de rd.random() \u00e0 l'intervalle : \\([0;p]\\) (succ\u00e8s) ou \\(]p;1]\\) (\u00e9chec) : Exercice 1 \u00c9nonc\u00e9 Correction Q1 Correction Q2 On consid\u00e8re une urne comportant 3 boules blanches et 5 boules noires. Cr\u00e9er une fonction tirage() renvoyant la valeur 1 si la boule tir\u00e9e est blanche, et la valeur 0 si la boule tir\u00e9e est noire. Simuler 100 000 fois cette exp\u00e9rience al\u00e9atoire et afficher la fr\u00e9quence d'apparition d'une boule blanche. 1 2 3 4 5 6 7 8 9 import numpy as np import numpy.random as rd def tirage (): val_alea = rd . random () if val_alea < 3 / 8 : return 1 else : return 0 1 2 3 4 5 6 nb_tirages = 10 ** 5 somme_blanches = 0 for k in range ( nb_tirages ): somme_blanches += tirage () print ( somme_blanches / nb_tirages ) Exercice 2 inspir\u00e9 par Ecricome 2018 \u00c9nonc\u00e9 Correction Q1 Correction Q2 Correction Q3 On consid\u00e8re une urne \\(U\\) contenant deux boules blanches et une boule noire indiscernables au toucher, ainsi qu\u2019une urne \\(V\\) contenant une boule blanche et trois boules noires, elles aussi indiscernables au toucher. On effectue une suite de tirages d\u2019une boule dans ces urnes en proc\u00e9dant comme suit : le premier tirage a lieu dans l\u2019urne U ; tous les tirages s\u2019effectuent avec remise de la boule pioch\u00e9e dans l\u2019urne dont elle provient; si l\u2019on pioche une boule blanche lors d\u2019un tirage, le tirage suivant a lieu dans l\u2019autre urne; si l\u2019on pioche une boule noire lors d\u2019un tirage, le tirage suivant a lieu dans la m\u00eame urne. Pour tout entier naturel non nul \\(n\\) , on note \\(X_n\\) la variable al\u00e9atoire \u00e9gale au nombre de boules blanches pioch\u00e9es au cours des \\(n\\) premiers tirages. On rappelle qu\u2019en Python, l\u2019instruction rd.randint(1,k) renvoie un entier al\u00e9atoire compris entre 1 et k-1 . Q1. Recopier et compl\u00e9ter les lignes \u00e0 pointill\u00e9s du script Python ci-dessous afin qu\u2019il simule la variable al\u00e9atoire \\(X_2\\) : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import numpy as np import numpy.random as rd def simulation (): tirage1 = rd . randint ( 1 , 4 ) if tirage1 < 3 : res1 = 1 tirage2 = rd . randint ( 1 , 5 ) if tirage2 == 1 : res2 = 1 else : res2 = 0 else : res1 = 0 tirage2 = ... if tirage2 < 3 : res2 = ... else : res2 = ... X = ... + ... return X Q2. \u00c9crire une fonction freq(n) qui renvoie la valeur moyenne du nombre de boules blanches tir\u00e9es sur n exp\u00e9riences r\u00e9alis\u00e9es. Q3. En d\u00e9duire \\(E(X_2)\\) et retrouver ce r\u00e9sultat par un calcul th\u00e9orique. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import numpy as np import numpy.random as rd def simulation (): tirage1 = rd . randint ( 1 , 4 ) if tirage1 < 3 : res1 = 1 tirage2 = rd . randint ( 1 , 5 ) if tirage2 == 1 : res2 = 1 else : res2 = 0 else : res1 = 0 tirage2 = rd . randint ( 1 , 4 ) if tirage2 < 3 : res2 = 1 else : res2 = 0 X = res1 + res2 return X 1 2 3 4 5 def freq ( n ): compteur = 0 for k in range ( n ): compteur += simulation () return compteur / n Exp\u00e9rimentaliment : >>> freq ( 10 ** 6 ) 1.055416 Th\u00e9oriquement, en faisant un arbre de probalit\u00e9s, \\[E(X_2) = 2 \\times \\dfrac{2}{6} + 1 \\times \\dfrac{1}{2} + 1 \\times \\dfrac{2}{9} = \\dfrac{57}{54}\\]","title":"1. Rappels sur les exp\u00e9riences de Bernoulli"},{"location":"TD03/TD03/#2-retour-sur-le-while","text":"Exercice 3 \u00c9nonc\u00e9 \u00c9crire un code o\u00f9 l'utilisateur doit deviner un nombre choisi al\u00e9atoirement par l'ordinateur entre 1 et 100. L'utilisateur devra \u00eatre guid\u00e9 apr\u00e8s chaque proposition par les instructions \u00abtrop grand\u00bb ou \u00abtrop petit\u00bb . aide : 1 2 3 4 5 6 7 8 import numpy as np import numpy.random as rd nb_secret = ... prop = int ( input ( \"proposition ? \" )) while ... ...","title":"2. Retour sur le while."},{"location":"TD03/TD03/#3-retour-sur-les-suites","text":"Exercice 4 extrait du sujet 0 Ecricome \u00c9nonc\u00e9 On consid\u00e8re la suite \\((u_n)_{n \\in \\mathbb{N}^*}\\) d\u00e9finie par \\(u_1=\\dfrac{2}{3}\\) et, \\(\\forall n \\in \\mathbb{N}^*, u_{n+1}=\\dfrac{n+1}{3n}u_n\\) . Calculer \\(u_1\\) et \\(u_3\\) . Donner les r\u00e9sultats sous forme de fraction irr\u00e9ductible. Compl\u00e9ter la fonction Python ci-desous qui prend en entr\u00e9e la valeur \\(n\\) et renvoie la valeur de \\(u_n\\) . 1 2 3 4 5 def suite ( n ): u = 2 / 3 for k in range ( 1 , n ): u = ... return u Exercice 5 inspir\u00e9 du sujet Ecricome 2019 \u00c9nonc\u00e9 Soit \\(g\\) la fonction num\u00e9rique r\u00e9elle d\u00e9finie sur l'intervalle \\(]0;+\\infty[\\) par : \\[ g(x)=2x-1+\\ln \\left( \\frac{x}{x+1} \\right) \\] Q1. \u00c9crire en Python la fonction \\(g\\) . Le script Python ci-dessous construit un vecteur ligne contenant les 50 premiers termes de la suite \\((u_n)_{n \\geqslant 1}\\) . 1 2 3 4 5 6 7 8 9 10 u = np . zeros ( 50 ) for n in range ( 1 , 50 ): u [ n ] = 2 * n - 1 - g ( n ) S = np . cumsum ( u ) X = np . arange ( 50 ) plt . plot ( X , S ) plt . show () Q2. Interpr\u00e9ter le contenu de la ligne 6 dans le contexte de l'\u00e9nonc\u00e9. Q3. Ex\u00e9cutez le script pr\u00e9c\u00e9dent et observez le graphique obtenu. Q4. Sur ce m\u00eame graphique, tracez la courbe repr\u00e9sentative de la fonction \\(\\ln\\) .","title":"3. Retour sur les suites"}]}